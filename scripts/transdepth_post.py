import os
import h5py
import argparse
import numpy as np
from pathlib import Path

parser = argparse.ArgumentParser("Script to post-process files generated by the transmission depth pipeline")

parser.add_argument('parent_dir', help='Path to directory containing hdf5 files')
parser.add_argument('output_dir', help='Path to output directory for hdf5 files')
# NOT IMPLEMENTED YET
parser.add_argument('--reverse', help='Partially reverse the simplification of files', default=False, type=bool)

args = parser.parse_args()

output_dir = Path(args.output_dir)
parent_dir = Path(args.parent_dir)
reverse = args.reverse

depth_keys = ["distance", "normals"]


def write_file(file, key: str, data: np.ndarray, compression: str = "gzip"):
    if data.dtype.char == 'S':
        file.create_dataset(key, data=data, dtype=data.dtype)
    else:
        file.create_dataset(key, data=data, compression=compression)


def process_file(filename, out_file):
    with h5py.File(filename, 'r') as data:
        with h5py.File(out_file, 'w') as data_out:
            handled_keys = []
            for key in [key for key in data.keys() if 'transmask' in key]:
                if key.endswith('version'):
                    continue
                layer_num = int(key.split("_")[1])
                mask = np.array(data[key])
                stereo = len(mask.shape) >= 3 and mask.shape[0] == 2

                mask_out = mask.copy()[..., 0]

                for image_key in depth_keys:
                    # we want the depth *behind* a layer of transparency, so e.g depth 1 is relevant behind transmask 0
                    image_key = image_key + '_' + str(layer_num + 1)
                    if not image_key in data.keys():
                        continue

                    image_out = np.array(data[image_key])

                    if stereo:
                        for i in range(2):
                            side_mask = mask[i]
                            # convert mask to grayscale
                            graymask = np.dot(side_mask[..., :3], [0.299, 0.587, 0.114])
                            graymask[graymask < 0.1] = 0

                            image_out[i][graymask < 0.1] = None
                            mask_out[i] = graymask
                    else:
                        graymask = np.dot(mask[..., :3], [0.299, 0.587, 0.114])
                        graymask[graymask < 0.1] = 0
                        image_out[graymask < 0.1] = None
                        mask_out = graymask

                    write_file(data_out, image_key, image_out)
                    handled_keys.append(image_key)
                write_file(data_out, key, mask_out)
                handled_keys.append(key)

            # write unmodified keys
            for key in [key for key in data.keys() if key not in handled_keys]:
                # print("write unmodified key", key);
                write_file(data_out, key, np.array(data[key]))


def reverse_process_file(filename, out_file):
    with h5py.File(filename, 'r') as data:
        with h5py.File(out_file, 'w') as data_out:
            handled_keys = []
            last = dict()
            for image_key in depth_keys:
                depth = 0
                while image_key+"_"+str(depth) in data.keys():
                    img_1 = np.array(data[image_key+"_"+str(depth)])

                    if image_key in last.keys():
                        # print("combining last image with depth", depth)
                        x = np.where(np.isnan(img_1), last[image_key], img_1)
                        write_file(data_out, image_key+"_"+str(depth), x)
                        handled_keys.append(image_key+"_"+str(depth))
                        last[image_key] = x
                    else:
                        last[image_key] = img_1
                    depth += 1

            # write unmodified keys
            for key in [key for key in data.keys() if key not in handled_keys]:
                # print("write unmodified key", key);
                write_file(data_out, key, np.array(data[key]))


def process_directory(parent_dir, output_dir, reverse):
    tasks = []
    for root, dirs, files in os.walk(parent_dir):
        for name in files:
            file_path = os.path.join(root, name)
            if file_path.endswith(".hdf5"):
                rel = os.path.relpath(file_path, parent_dir)
                out_file = os.path.join(output_dir, rel)
                tasks.append((file_path, out_file))

    total = len(tasks)
    i = 0
    for file_path, out_file in tasks:
        i += 1
        print(str(i), "/", total, "processing file", file_path)
        if Path(out_file).exists():
            print("file exists, skipping")
            continue
        Path(out_file).parent.mkdir(parents=True, exist_ok=True)
        if reverse:
            reverse_process_file(file_path, out_file)
        else:
            process_file(file_path, out_file)


process_directory(parent_dir, output_dir, reverse)